{"version":3,"file":"static/js/json_index.85bad41b.chunk.js","mappings":"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","sources":["../node_modules/src/.internal/core/render/Picture.ts","../node_modules/src/.internal/core/render/gradients/Gradient.ts","../node_modules/src/.internal/core/render/gradients/LinearGradient.ts","../node_modules/src/.internal/core/render/Star.ts","../node_modules/src/.internal/core/render/HeatLegend.ts","../node_modules/src/.internal/core/render/Triangle.ts","../node_modules/src/.internal/core/render/Slider.ts","../node_modules/src/.internal/core/render/patterns/GrainPattern.ts","../node_modules/src/.internal/core/render/gradients/RadialGradient.ts","../node_modules/src/.internal/core/render/patterns/CirclePattern.ts","../node_modules/src/.internal/core/render/patterns/LinePattern.ts","../node_modules/src/.internal/core/render/patterns/RectanglePattern.ts","../node_modules/src/.internal/core/render/patterns/PathPattern.ts"],"sourcesContent":["import type { IPicture } from \"./backend/Renderer\";\nimport type { Color } from \"../util/Color\";\n\nimport { Sprite, ISpriteEvents, ISpriteSettings, ISpritePrivate } from \"./Sprite\";\n\nimport * as $type from \"../util/Type\";\n\nexport interface IPictureSettings extends ISpriteSettings {\n\n\t/**\n\t * A source URI of the image.\n\t *\n\t * Can be relative or absolute URL, or data-uri.\n\t */\n\tsrc?: string;\n\n\t/**\n\t * CORS settings for loading the image. Defaults to \"anonymous\".\n\t *\n\t * @since 5.3.6\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin} for more info\n\t */\n\tcors?: string | null;\n\n\t/**\n\t * Color of the element's shadow.\n\t *\n\t * For this to work at least one of the following needs to be set as well:\n\t * `shadowBlur`, `shadowOffsetX`, `shadowOffsetY`.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowColor?: Color | null;\n\n\t/**\n\t * Blurriness of the the shadow.\n\t *\n\t * The bigger the number, the more blurry shadow will be.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowBlur?: number;\n\n\t/**\n\t * Horizontal shadow offset in pixels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOffsetX?: number;\n\n\t/**\n\t * Vertical shadow offset in pixels.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOffsetY?: number;\n\n\t/**\n\t * Opacity of the shadow (0-1).\n\t *\n\t * If not set, will use the same as `fillOpacity` of the element.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/shadows/} for more info\n\t */\n\tshadowOpacity?: number;\n\n}\n\nexport interface IPicturePrivate extends ISpritePrivate {\n}\n\nexport interface IPictureEvents extends ISpriteEvents {\n\n\t/**\n\t * Invoked when picture is loaded.\n\t */\n\tloaded: {};\n\n\t/**\n\t * Invoked when picture load error happens.\n\t */\n\tloaderror: {};\n}\n\n/**\n * Displays an image.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/images/} for more info\n * @important\n */\nexport class Picture extends Sprite {\n\n\tdeclare public _settings: IPictureSettings;\n\tdeclare public _privateSettings: IPicturePrivate;\n\n\tpublic _display: IPicture = this._root._renderer.makePicture(undefined);\n\n\tpublic static className: string = \"Picture\";\n\tpublic static classNames: Array<string> = Sprite.classNames.concat([Picture.className]);\n\tdeclare public _events: IPictureEvents;\n\n\tpublic _changed() {\n\t\tsuper._changed();\n\n\t\tif (this.isDirty(\"width\")) {\n\t\t\tconst width = this.get(\"width\");\n\t\t\tthis._display.width = $type.isNumber(width) ? width : undefined;\n\t\t}\n\n\t\tif (this.isDirty(\"height\")) {\n\t\t\tconst height = this.get(\"height\");\n\t\t\tthis._display.height = $type.isNumber(height) ? height : undefined;\n\t\t}\n\n\t\tif (this.isDirty(\"shadowColor\")) {\n\t\t\tthis._display.clear();\n\t\t\tconst shadowColor = this.get(\"shadowColor\");\n\t\t\tthis._display.shadowColor = shadowColor == null ? undefined : shadowColor;\n\t\t}\n\n\t\tif (this.isDirty(\"shadowBlur\")) {\n\t\t\tthis._display.clear();\n\t\t\tthis._display.shadowBlur = this.get(\"shadowBlur\");\n\t\t}\n\n\t\tif (this.isDirty(\"shadowOffsetX\")) {\n\t\t\tthis._display.clear();\n\t\t\tthis._display.shadowOffsetX = this.get(\"shadowOffsetX\");\n\t\t}\n\n\t\tif (this.isDirty(\"shadowOffsetY\")) {\n\t\t\tthis._display.clear();\n\t\t\tthis._display.shadowOffsetY = this.get(\"shadowOffsetY\");\n\t\t}\n\n\t\tif (this.isDirty(\"shadowOpacity\")) {\n\t\t\tthis._display.clear();\n\t\t\tthis._display.shadowOpacity = this.get(\"shadowOpacity\");\n\t\t}\n\n\t\tif (this.isDirty(\"src\") || this.isDirty(\"cors\")) {\n\t\t\tthis._display.clear();\n\t\t\tthis._load();\n\t\t}\n\t}\n\n\tprotected _load() {\n\t\tconst src = this.get(\"src\");\n\t\tif (src) {\n\t\t\tlet eventType: \"loaded\" | \"loaderror\" = \"loaded\";\n\t\t\tconst image = new Image();\n\t\t\timage.crossOrigin = this.get(\"cors\", \"anonymous\");\n\t\t\timage.src = src!;\n\t\t\timage.decode().then(() => {\n\t\t\t\tthis._display.image = image;\n\t\t\t\tthis._updateSize();\n\t\t\t}).catch((_error: any) => {\n\t\t\t\teventType = \"loaderror\";\n\t\t\t});\n\n\t\t\tif (this.events.isEnabled(eventType)) {\n\t\t\t\tthis.events.dispatch(eventType, { type: eventType, target: this });\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic _updateSize() {\n\t\tsuper._updateSize();\n\n\t\tconst image = this._display.image;\n\t\tif (image) {\n\t\t\tlet w = this.getPrivate(\"width\", this.get(\"width\"));\n\t\t\tlet h = this.getPrivate(\"height\", this.get(\"height\"));\n\t\t\tconst r = image.width && image.height ? image.width / image.height : 0;\n\n\t\t\tif ($type.isNumber(w) && $type.isNumber(h)) {\n\t\t\t\tthis._display.width = w;\n\t\t\t\tthis._display.height = h;\n\t\t\t}\n\t\t\telse if ($type.isNumber(w) && r) {\n\t\t\t\th = w / r;\n\t\t\t}\n\t\t\telse if ($type.isNumber(h) && r) {\n\t\t\t\tw = h * r;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tw = image.width;\n\t\t\t\th = image.height;\n\t\t\t}\n\n\t\t\tif ($type.isNumber(w)) {\n\t\t\t\tthis._display.width = w;\n\t\t\t}\n\t\t\tif ($type.isNumber(h)) {\n\t\t\t\tthis._display.height = h;\n\t\t\t}\n\t\t\tthis.markDirtyBounds();\n\t\t\tthis.markDirty();\n\t\t}\n\t}\n}\n","import type { IBounds } from \"../../util/IBounds\"\nimport type { IGradient, IGradientStop } from \"../backend/Renderer\";\nimport type { Sprite } from \"../Sprite\";\n\nimport { Entity, IEntitySettings, IEntityPrivate } from \"../../util/Entity\"\n\n\nexport interface IGradientSettings extends IEntitySettings {\n\n\t/**\n\t * A list of color steps for the gradient.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more info\n\t */\n\tstops?: Array<IGradientStop>;\n\n\t/**\n\t * Gradient target.\n\t */\n\ttarget?: Sprite;\n\n}\n\nexport interface IGradientPrivate extends IEntityPrivate {\n}\n\n/**\n * Base class for gradients.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more info\n */\nexport abstract class Gradient extends Entity {\n\n\tdeclare public _settings: IGradientSettings;\n\tdeclare public _privateSettings: IGradientPrivate;\n\n\tpublic static className: string = \"Gradient\";\n\tpublic static classNames: Array<string> = Entity.classNames.concat([Gradient.className]);\n\n\tprotected _afterNew() {\n\t\t// Applying themes because gradient will not have parent\n\t\tsuper._afterNewApplyThemes();\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getFill(_target: Sprite): IGradient {\n\t\treturn {\n\t\t\taddColorStop: (_offset: number, _color: string) => { }\n\t\t};\n\t}\n\n\tpublic _changed() {\n\t\tsuper._changed();\n\n\t\t//if (this.isDirty(\"target\") && this.get(\"target\")) {\n\t\t//\tthis.get(\"target\")!.events.on(\"boundschanged\", () => {\n\n\t\t//\t});\n\t\t//}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getBounds(target: Sprite): IBounds {\n\t\tconst gradientTarget = this.get(\"target\");\n\t\tif (gradientTarget) {\n\t\t\tlet bounds = gradientTarget.globalBounds();\n\n\t\t\tconst p0 = target.toLocal({ x: bounds.left, y: bounds.top });\n\t\t\tconst p1 = target.toLocal({ x: bounds.right, y: bounds.top });\n\t\t\tconst p2 = target.toLocal({ x: bounds.right, y: bounds.bottom });\n\t\t\tconst p3 = target.toLocal({ x: bounds.left, y: bounds.bottom });\n\n\t\t\treturn {\n\t\t\t\tleft: Math.min(p0.x, p1.x, p2.x, p3.x),\n\t\t\t\ttop: Math.min(p0.y, p1.y, p2.y, p3.y),\n\t\t\t\tright: Math.max(p0.x, p1.x, p2.x, p3.x),\n\t\t\t\tbottom: Math.max(p0.y, p1.y, p2.y, p3.y)\n\t\t\t}\n\t\t}\n\t\treturn target._display.getLocalBounds();\n\t}\n\n}\n","import type { IGradient } from \"../backend/Renderer\";\nimport type { Sprite } from \"../Sprite\";\n\nimport { Gradient, IGradientSettings, IGradientPrivate } from \"./Gradient\";\nimport { Color } from \"../../util/Color\";\n\nimport * as $array from \"../../util/Array\";\nimport * as $type from \"../../util/Type\";\nimport * as $math from \"../../util/Math\";\n\n\nexport interface ILinearGradientSettings extends IGradientSettings {\n\n\t/**\n\t * Gradient rotation, in degrees.\n\t *\n\t * @default 90\n\t */\n\trotation?: number;\n\n}\n\nexport interface ILinearGradientPrivate extends IGradientPrivate {\n}\n\n/**\n * Linear gradient.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more info\n */\nexport class LinearGradient extends Gradient {\n\n\tdeclare public _settings: ILinearGradientSettings;\n\tdeclare public _privateSettings: ILinearGradientPrivate;\n\n\tpublic static className: string = \"LinearGradient\";\n\tpublic static classNames: Array<string> = Gradient.classNames.concat([LinearGradient.className]);\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getFill(target: Sprite): IGradient {\n\t\tconst rotation = this.get(\"rotation\", 0);\n\t\tlet bounds = this.getBounds(target);\n\n\t\tlet l = bounds.left || 0;\n\t\tlet r = bounds.right || 0;\n\t\tlet t = bounds.top || 0;\n\t\tlet b = bounds.bottom || 0;\n\n\t\tlet cos = $math.cos(rotation);\n\t\tlet sin = $math.sin(rotation);\n\n\t\tlet w = cos * (r - l);\n\t\tlet h = sin * (b - t);\n\n\t\tlet longer = Math.max(w, h);\n\n\t\tconst gradient = this._root._renderer.createLinearGradient(\n\t\t\tl,\n\t\t\tt,\n\t\t\tl + longer * cos,\n\t\t\tt + longer * sin\n\t\t);\n\n\t\tconst stops = this.get(\"stops\")!;\n\t\tif (stops) {\n\t\t\tlet i = 0;\n\t\t\t$array.each(stops, (stop) => {\n\n\t\t\t\tlet offset = stop.offset;\n\n\t\t\t\tif (!$type.isNumber(offset)) {\n\t\t\t\t\toffset = i / (stops.length - 1);\n\t\t\t\t}\n\n\t\t\t\tlet opacity = stop.opacity;\n\n\t\t\t\tif (!$type.isNumber(opacity)) {\n\t\t\t\t\topacity = 1;\n\t\t\t\t}\n\n\t\t\t\tlet color = stop.color;\n\n\t\t\t\tif (color) {\n\n\t\t\t\t\tconst lighten = stop.lighten;\n\t\t\t\t\tif (lighten) {\n\t\t\t\t\t\tcolor = Color.lighten(color, lighten)\n\t\t\t\t\t}\n\n\t\t\t\t\tconst brighten = stop.brighten;\n\t\t\t\t\tif (brighten) {\n\t\t\t\t\t\tcolor = Color.brighten(color, brighten)\n\t\t\t\t\t}\n\n\t\t\t\t\tgradient.addColorStop(offset, 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + opacity + ')');\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t})\n\t\t}\n\t\treturn gradient;\n\t}\n}\n","import { Graphics, IGraphicsSettings, IGraphicsPrivate } from \"./Graphics\";\r\nimport type { Percent } from \"../../core/util/Percent\";\r\nimport * as $utils from \"../../core/util/Utils\";\r\n\r\nexport interface IStarSettings extends IGraphicsSettings {\r\n\r\n\t/**\r\n\t * Star's radius in pixels.\r\n\t */\r\n\tradius?: number;\r\n\r\n\t/**\r\n\t * Star's inner radius in pixels.\r\n\t */\r\n\tinnerRadius?: number | Percent;\r\n\r\n\t/**\r\n\t * Number of spikes\r\n\t */\r\n\tspikes?: number;\r\n\r\n}\r\n\r\nexport interface IStarPrivate extends IGraphicsPrivate {\r\n}\r\n\r\n/**\r\n * Draws a Star.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\r\n * @important\r\n */\r\nexport class Star extends Graphics {\r\n\r\n\tdeclare public _settings: IStarSettings;\r\n\tdeclare public _privateSettings: IStarPrivate;\r\n\r\n\tpublic static className: string = \"Star\";\r\n\tpublic static classNames: Array<string> = Graphics.classNames.concat([Star.className]);\r\n\r\n\tpublic _beforeChanged() {\r\n\t\tsuper._beforeChanged();\r\n\r\n\t\tif (this.isDirty(\"radius\") || this.isDirty(\"innerRadius\") || this.isDirty(\"spikes\")) {\r\n\t\t\tthis._clear = true;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic _changed() {\r\n\t\tsuper._changed();\r\n\r\n\t\tif (this._clear) {\r\n\t\t\tconst display = this._display;\r\n\t\t\tconst r = this.get(\"radius\", 0);\r\n\t\t\tconst ir = $utils.relativeToValue(this.get(\"innerRadius\", 0), r);\r\n\t\t\tconst spikes = this.get(\"spikes\", 0);\r\n\t\t\tconst step = Math.PI / spikes;\r\n\t\t\tlet angle = Math.PI / 2 * 3;\r\n\r\n\t\t\tdisplay.moveTo(0, - r)\r\n\r\n\t\t\tfor (let i = 0; i < spikes; i++) {\r\n\t\t\t\tdisplay.lineTo(Math.cos(angle) * r, Math.sin(angle) * r)\r\n\t\t\t\tangle += step\r\n\r\n\t\t\t\tdisplay.lineTo(Math.cos(angle) * ir, Math.sin(angle) * ir)\r\n\t\t\t\tangle += step\r\n\t\t\t}\r\n\t\t\tdisplay.lineTo(0, -r)\r\n\t\t\tdisplay.closePath();\r\n\t\t}\r\n\t}\r\n}\r\n","import type { IPoint } from \"../../core/util/IPoint\";\n\nimport { Container, IContainerSettings, IContainerPrivate } from \"./Container\";\nimport { Label } from \"../../core/render/Label\";\nimport { p100 } from \"../../core/util/Percent\";\nimport { RoundedRectangle } from \"../../core/render/RoundedRectangle\";\nimport { Template } from \"../../core/util/Template\";\nimport { ListTemplate } from \"../../core/util/List\";\nimport { Color } from \"../../core/util/Color\";\nimport { Tooltip } from \"../../core/render/Tooltip\";\nimport { LinearGradient } from \"../../core/render/gradients/LinearGradient\";\n\nimport * as $utils from \"../../core/util/Utils\";\nimport * as $type from \"../../core/util/Type\";\n\nexport interface IHeatLegendSettings extends IContainerSettings {\n\n\t/**\n\t * Starting (lowest value) color.\n\t */\n\tstartColor: Color;\n\n\t/**\n\t * Ending (highest value) color.\n\t */\n\tendColor: Color;\n\n\t/**\n\t * Start (lowest) value.\n\t */\n\tstartValue?: number;\n\n\t/**\n\t * End (highest) value.\n\t */\n\tendValue?: number;\n\n\t/**\n\t * Text for start label.\n\t */\n\tstartText?: string;\n\n\t/**\n\t * Text for end label.\n\t */\n\tendText?: string;\n\n\t/**\n\t * Number of steps\n\t *\n\t * @default 1\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/legend/heat-legend/#Gradient_or_steps} for more info\n\t */\n\tstepCount?: number;\n\n\t/**\n\t * Orientation of the heat legend.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/legend/heat-legend/#Orientation} for more info\n\t */\n\torientation: \"horizontal\" | \"vertical\";\n\n}\n\nexport interface IHeatLegendPrivate extends IContainerPrivate {\n}\n\n/**\n * Heat legend.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/legend/heat-legend/} for more info\n */\nexport class HeatLegend extends Container {\n\n\t/**\n\t * A [[Container]] that all labels are placed in.\n\t *\n\t * @default Container.new()\n\t */\n\tpublic readonly labelContainer: Container = this.children.push(Container.new(this._root, {}));\n\n\t/**\n\t * A [[Container]] that all markers are placed in.\n\t *\n\t * @default Container.new()\n\t */\n\tpublic readonly markerContainer: Container = this.children.push(Container.new(this._root, {}));\n\n\t/**\n\t * A start [[Label]].\n\t *\n\t * @default Label.new()\n\t */\n\tpublic readonly startLabel: Label = this.labelContainer.children.push(Label.new(this._root, { themeTags: [\"start\"] }));\n\n\t/**\n\t * An end [[Label]].\n\t *\n\t * @default Label.new()\n\t */\n\tpublic readonly endLabel: Label = this.labelContainer.children.push(Label.new(this._root, { themeTags: [\"end\"] }));\n\n\tpublic static className: string = \"HeatLegend\";\n\tpublic static classNames: Array<string> = Container.classNames.concat([HeatLegend.className]);\n\n\tdeclare public _settings: IHeatLegendSettings;\n\tdeclare public _privateSettings: IHeatLegendPrivate;\n\n\n\tprotected _afterNew() {\n\t\tthis._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"heatlegend\", this._settings.orientation]);\n\t\tsuper._afterNew();\n\t\tthis.set(\"tooltip\", Tooltip.new(this._root, {\n\t\t\tthemeTags: [\"heatlegend\"]\n\t\t}));\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic makeMarker(): RoundedRectangle {\n\t\tconst marker = this.markers.make();\n\t\tmarker.states.create(\"disabled\", {});\n\t\treturn marker;\n\t}\n\n\t/**\n\t * List of rectangle elements used for default legend markers.\n\t *\n\t * @default new ListTemplate<RoundedRectangle>\n\t */\n\tpublic readonly markers: ListTemplate<RoundedRectangle> = new ListTemplate(\n\t\tTemplate.new({}),\n\t\t() => RoundedRectangle._new(this._root, {\n\t\t\tthemeTags: $utils.mergeTags(this.markers.template.get(\"themeTags\", []), [this.get(\"orientation\"), \"heatlegend\", \"marker\"])\n\t\t}, [this.markers.template])\n\t);\n\n\n\t/**\n\t * Moves and shows tooltip at specific value.\n\t *\n\t * Can also specify optional text to show in tooltip, as well as the color.\n\t *\n\t * @param  value  Value\n\t * @param  text   Text\n\t * @param  color  Color\n\t */\n\tpublic showValue(value: number, text?: string, color?: Color) {\n\t\tconst tooltip = this.getTooltip();\n\t\tif (tooltip && $type.isNumber(value)) {\n\n\t\t\tconst startValue = this.get(\"startValue\", 0);\n\t\t\tconst endValue = this.get(\"endValue\", 1);\n\n\t\t\tconst c = (value - startValue) / (endValue - startValue);\n\t\t\tconst startColor = this.get(\"startColor\")!;\n\t\t\tconst endColor = this.get(\"endColor\")!;\n\n\t\t\tif (!text) {\n\t\t\t\ttext = this.getNumberFormatter().format(value);\n\t\t\t}\n\n\t\t\tif (!color) {\n\t\t\t\tcolor = Color.interpolate(c, startColor, endColor);\n\t\t\t}\n\n\t\t\ttooltip.label.set(\"text\", text);\n\t\t\tlet p:IPoint;\n\n\t\t\tif (this.get(\"orientation\") == \"vertical\") {\n\t\t\t\tp = this.markerContainer.toGlobal({ x: 0, y: this.innerHeight() * (1 - c) });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp = this.markerContainer.toGlobal({ x: this.innerWidth() * c, y: 0 });\n\t\t\t}\n\n\t\t\tlet background = tooltip.get(\"background\");\n\t\t\tif (background) {\n\t\t\t\tbackground.set(\"fill\", Color.interpolate(c, startColor, endColor))\n\t\t\t}\n\t\t\ttooltip.set(\"pointTo\", p);\n\t\t\ttooltip.show();\n\t\t}\n\t}\n\n\tpublic _prepareChildren() {\n\t\tsuper._prepareChildren();\n\n\t\tconst labelContainer = this.labelContainer;\n\t\tconst orientation = this.get(\"orientation\");\n\t\tconst startLabel = this.startLabel;\n\t\tconst endLabel = this.endLabel;\n\t\tconst tooltip = this.getTooltip();\n\n\t\tif (this.isDirty(\"orientation\")) {\n\t\t\tif (orientation == \"vertical\") {\n\t\t\t\tthis.markerContainer.setAll({ layout: this._root.verticalLayout, height: p100 });\n\t\t\t\tthis.set(\"layout\", this._root.horizontalLayout);\n\t\t\t\tstartLabel.setAll({ y: p100, x: undefined, centerY: p100, centerX: p100 });\n\t\t\t\tendLabel.setAll({ y: 0, x: undefined, centerY: 0, centerX: p100 });\n\t\t\t\tlabelContainer.setAll({ height: p100, width: undefined });\n\t\t\t\tif (tooltip) {\n\t\t\t\t\ttooltip.set(\"pointerOrientation\", \"horizontal\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.markerContainer.setAll({ layout: this._root.horizontalLayout, width: p100 });\n\t\t\t\tthis.set(\"layout\", this._root.verticalLayout);\n\t\t\t\tstartLabel.setAll({ x: 0, y: undefined, centerX: 0, centerY: 0 });\n\t\t\t\tendLabel.setAll({ x: p100, y: undefined, centerX: p100, centerY: 0 });\n\t\t\t\tlabelContainer.setAll({ width: p100, height: undefined });\n\t\t\t\tif (tooltip) {\n\t\t\t\t\ttooltip.set(\"pointerOrientation\", \"vertical\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.isDirty(\"stepCount\")) {\n\t\t\tconst stepCount = this.get(\"stepCount\", 1);\n\t\t\tconst startColor = this.get(\"startColor\")!;\n\t\t\tconst endColor = this.get(\"endColor\")!;\n\t\t\tthis.markerContainer.children.clear();\n\t\t\tif (stepCount > 1) {\n\t\t\t\tfor (let i = 0; i < stepCount; i++) {\n\t\t\t\t\tconst marker = this.makeMarker();\n\n\t\t\t\t\tif (orientation == \"vertical\") {\n\t\t\t\t\t\tthis.markerContainer.children.moveValue(marker, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.markerContainer.children.push(marker);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (startColor && endColor) {\n\t\t\t\t\t\tmarker.set(\"fill\", Color.interpolate(i / stepCount, startColor, endColor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (stepCount == 1) {\n\t\t\t\tconst marker = this.makeMarker();\n\t\t\t\tthis.markerContainer.children.push(marker);\n\t\t\t\tconst gradient = LinearGradient.new(this._root, { stops: [{ color: startColor }, { color: endColor }] });\n\n\t\t\t\tif (orientation == \"vertical\") {\n\t\t\t\t\tgradient.set(\"rotation\", 90);\n\t\t\t\t\tlet stops = gradient.get(\"stops\");\n\t\t\t\t\tif (stops) {\n\t\t\t\t\t\tstops.reverse();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgradient.set(\"rotation\", 0);\n\t\t\t\t}\n\t\t\t\tif (startColor && endColor) {\n\t\t\t\t\tmarker.set(\"fillGradient\", gradient);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.isDirty(\"startText\") || this.isDirty(\"startValue\")) {\n\t\t\tstartLabel.set(\"text\", this.get(\"startText\", this.getNumberFormatter().format(this.get(\"startValue\", 0))));\n\t\t}\n\n\t\tif (this.isDirty(\"endText\") || this.isDirty(\"endValue\")) {\n\t\t\tendLabel.set(\"text\", this.get(\"endText\", this.getNumberFormatter().format(this.get(\"endValue\", 1))))\n\t\t}\n\t}\n}\n","import { Graphics, IGraphicsSettings, IGraphicsPrivate } from \"./Graphics\";\r\n\r\nexport interface ITriangleSettings extends IGraphicsSettings {\r\n}\r\n\r\nexport interface ITrianglePrivate extends IGraphicsPrivate {\r\n}\r\n\r\n/**\r\n * Draws a triangle.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/graphics/} for more info\r\n * @important\r\n */\r\nexport class Triangle extends Graphics {\r\n\r\n\tdeclare public _settings: ITriangleSettings;\r\n\tdeclare public _privateSettings: ITrianglePrivate;\r\n\r\n\tpublic static className: string = \"Triangle\";\r\n\tpublic static classNames: Array<string> = Graphics.classNames.concat([Triangle.className]);\r\n\r\n\tpublic _beforeChanged() {\r\n\t\tsuper._beforeChanged();\r\n\r\n\t\tif (this.isDirty(\"width\") || this.isDirty(\"height\") || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\")) {\r\n\t\t\tthis._clear = true;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic _changed() {\r\n\t\tsuper._changed();\r\n\r\n\t\tif (this._clear && !this.get(\"draw\")) {\r\n\t\t\tthis._draw();\r\n\t\t}\r\n\t}\r\n\r\n\tprotected _draw() {\r\n\t\tconst w = this.width();\r\n\t\tconst h = this.height();\r\n\t\tconst display = this._display;\r\n\t\tdisplay.moveTo(-w / 2, h / 2);\r\n\t\tdisplay.lineTo(0, -h / 2);\r\n\t\tdisplay.lineTo(w / 2, h / 2);\r\n\t\tdisplay.lineTo(-w / 2, h / 2);\r\n\t\tdisplay.closePath();\r\n\r\n\t}\r\n\r\n\tpublic _updateSize() {\r\n\t\tthis.markDirty()\r\n\t\tthis._clear = true;\r\n\t}\r\n}\r\n","import { Scrollbar, IScrollbarPrivate, IScrollbarSettings, IScrollbarEvents } from \"./Scrollbar\";\r\n\r\nexport interface ISliderSettings extends IScrollbarSettings {\r\n}\r\n\r\nexport interface ISliderPrivate extends IScrollbarPrivate {\r\n}\r\n\r\nexport interface ISliderEvents extends IScrollbarEvents {\r\n}\r\n\r\n/**\r\n * A control that allows zooming chart's axes, or other uses requiring range\r\n * selection.\r\n */\r\nexport class Slider extends Scrollbar {\r\n\r\n\tdeclare public _settings: ISliderSettings;\r\n\tdeclare public _privateSettings: ISliderPrivate;\r\n\tdeclare public _events: ISliderEvents;\r\n\r\n\tpublic static className: string = \"Slider\";\r\n\tpublic static classNames: Array<string> = Scrollbar.classNames.concat([Slider.className]);\r\n\r\n\r\n\tprotected _afterNew() {\r\n\t\tthis._addOrientationClass();\r\n\t\tsuper._afterNew();\r\n\r\n\t\tthis.endGrip.setPrivate(\"visible\", false);\r\n\t\tthis.thumb.setPrivate(\"visible\", false);\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic updateGrips() {\r\n\t\tsuper.updateGrips();\r\n\t\tconst startGrip = this.startGrip;\r\n\t\tthis.endGrip.setAll({ x: startGrip.x(), y: startGrip.y() });\r\n\t\tthis.setRaw(\"end\", this.get(\"start\"));\r\n\t}\r\n}\r\n","import { Pattern, IPatternSettings, IPatternPrivate } from \"./Pattern\";\r\nimport { Color } from \"../../util/Color\";\r\n\r\nexport interface IGrainPatternSettings extends IPatternSettings {\r\n\r\n\t/**\r\n\t * Size of a grain in pixels.\r\n\t *\r\n\t * @default 1\r\n\t */\r\n\tsize?: number;\r\n\r\n\t/**\r\n\t * Density of noise.\r\n\t *\r\n\t * Value range: `0` (no noise applied) to `1` (noise is applied to every\r\n\t * pixel).\r\n\t *\r\n\t * The bigger the value, the higher chance that pixel will have another pixel\r\n\t * painted over with random opacity from `minOpacity` to `maxOpacity`.\r\n\t *\r\n\t * @default 1\r\n\t */\r\n\tdensity?: number;\r\n\r\n\t/**\r\n\t * Minimum opacity of a noise pixel.\r\n\t *\r\n\t * @default 0\r\n\t */\r\n\tminOpacity?: number;\r\n\r\n\t/**\r\n\t * Maximum opacity of a noise pixel.\r\n\t *\r\n\t * @default 0.3\r\n\t */\r\n\tmaxOpacity?: number;\r\n\r\n\t/**\r\n\t * An array of colors to randomly use for pixels.\r\n\t *\r\n\t * @default [color(0x000000)]\r\n\t */\r\n\tcolors?: Array<Color>;\r\n\r\n\t/**\r\n\t * Horizontal gap between noise pixels measured in `size`.\r\n\t *\r\n\t * @default 0\r\n\t */\r\n\thorizontalGap?: number;\r\n\r\n\t/**\r\n\t * Vertical gap between noise pixels measured in `size`.\r\n\t *\r\n\t * @default 0\r\n\t */\r\n\tverticalGap?: number;\r\n\r\n}\r\n\r\nexport interface IGrainPatternPrivate extends IPatternPrivate {\r\n}\r\n\r\n/**\r\n * Grain pattern.\r\n * \r\n * Allows to add grain (noise) effect to your [[Graphics]] objects.\r\n * \r\n * Note, grain pattern does not support `fill` and `color` setting.\r\n * Use `colors` setting to define colors of a grain pixels.\r\n * \r\n * Note, rotation setting is not supported by this pattern.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/#Grain_patterns} for more info\r\n * @since 5.5.0\r\n */\r\nexport class GrainPattern extends Pattern {\r\n\tdeclare public _settings: IGrainPatternSettings;\r\n\tdeclare public _privateSettings: IGrainPatternPrivate;\r\n\r\n\tpublic static className: string = \"GrainPattern\";\r\n\tpublic static classNames: Array<string> = Pattern.classNames.concat([GrainPattern.className]);\r\n\r\n\tpublic canvas: HTMLCanvasElement = document.createElement(\"canvas\");\r\n\tpublic context: CanvasRenderingContext2D = this.canvas.getContext(\"2d\")!;\r\n\r\n\tprotected _clearGrain: boolean = false;\r\n\r\n\tpublic _beforeChanged() {\r\n\t\t//document.body.appendChild(this.canvas); // temp\r\n\t\tthis.canvas.width = this.get(\"width\", 200);\r\n\t\tthis.canvas.height = this.get(\"height\", 200);\r\n\r\n\t\tif (this.isDirty(\"size\") || this.isDirty(\"density\") || this.isDirty(\"minOpacity\") || this.isDirty(\"maxOpacity\") || this.isDirty(\"colors\") || this.isDirty(\"horizontalGap\") || this.isDirty(\"verticalGap\")) {\r\n\t\t\tthis._clearGrain = true;\r\n\t\t}\r\n\t\tsuper._beforeChanged();\r\n\t}\r\n\r\n\r\n\tpublic _changed() {\r\n\t\tsuper._changed();\r\n\r\n\t\tif (this._clearGrain) {\r\n\t\t\tconst width = this.get(\"width\", 200);\r\n\t\t\tconst height = this.get(\"height\", 200);\r\n\r\n\t\t\tconst patternData = this.context.getImageData(0, 0, width, height);\r\n\r\n\t\t\tconst size = Math.max(1, this.get(\"size\", 1));\r\n\t\t\tconst minOpacity = this.get(\"minOpacity\", 0);\r\n\t\t\tconst maxOpacity = this.get(\"maxOpacity\", 0.3);\r\n\r\n\t\t\tconst colors = this.get(\"colors\", [this.get(\"color\", Color.fromHex(0x000000))])\r\n\r\n\t\t\tconst cols = width / size;\r\n\t\t\tconst rows = height / size;\r\n\t\t\tconst density = this.get(\"density\", 1);\r\n\t\t\tconst horizontalGap = this.get(\"horizontalGap\", 0) + 1;\r\n\t\t\tconst verticalGap = this.get(\"verticalGap\", 0) + 1;\r\n\r\n\t\t\tfor (let r = 0; r < rows; r++) {\r\n\r\n\t\t\t\tif (verticalGap > 0) {\r\n\t\t\t\t\tif (r / verticalGap != Math.round(r / verticalGap)) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (let c = 0; c < cols; c++) {\r\n\t\t\t\t\tconst color = colors[Math.floor(Math.random() * colors.length)];\r\n\t\t\t\t\tconst alpha = (minOpacity + Math.random() * (maxOpacity - minOpacity)) * 255;\r\n\t\t\t\t\tconst rnd = Math.random();\r\n\r\n\t\t\t\t\tif (horizontalGap > 0) {\r\n\t\t\t\t\t\tif (c / horizontalGap != Math.round(c / horizontalGap)) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (rnd < density) {\r\n\t\t\t\t\t\tthis._setRectData(c, r, size, width, patternData.data, color.r, color.g, color.b, alpha);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.context.putImageData(patternData, 0, 0);\r\n\t\t\tthis._pattern = this.context.createPattern(this.canvas, \"repeat\");\r\n\t\t}\r\n\r\n\t\tthis._clearGrain = false;\r\n\t}\r\n\r\n\tprotected _checkDirtyFill() {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected _setRectData(col: number, row: number, size: number, width: number, data: Uint8ClampedArray, rc: number, gc: number, bc: number, ac: number) {\r\n\t\tfor (var c = col * size; c < col * size + size; c++) {\r\n\t\t\tfor (var r = row * size; r < row * size + size; r++) {\r\n\t\t\t\tvar i = (r * width + c) * 4;\r\n\r\n\t\t\t\tdata[i] = rc;\r\n\t\t\t\tdata[i + 1] = gc;\r\n\t\t\t\tdata[i + 2] = bc;\r\n\t\t\t\tdata[i + 3] = ac;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","import type { IGradient } from \"../backend/Renderer\";\nimport type { Sprite } from \"../Sprite\";\nimport type { Percent } from \"../../util/Percent\";\n\nimport { Gradient, IGradientSettings, IGradientPrivate } from \"./Gradient\";\nimport { Color } from \"../../util/Color\";\n\nimport * as $array from \"../../util/Array\";\nimport * as $type from \"../../util/Type\";\nimport * as $utils from \"../../util/Utils\";\n\n\nexport interface IRadialGradientSettings extends IGradientSettings {\n\n\t/**\n\t * Gradient radius in pixels or percent (relative to the `target`).\n\t */\n\tradius?: number | Percent;\n\n\t/**\n\t * X position.\n\t */\n\tx?: number | Percent;\n\n\t/**\n\t * Y position.\n\t */\n\ty?: number | Percent;\n\n}\n\nexport interface IRadialGradientPrivate extends IGradientPrivate {\n}\n\n/**\n * Radial gradient.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/gradients/} for more info\n */\nexport class RadialGradient extends Gradient {\n\n\tdeclare public _settings: IRadialGradientSettings;\n\tdeclare public _privateSettings: IRadialGradientPrivate;\n\n\tpublic static className: string = \"RadialGradient\";\n\tpublic static classNames: Array<string> = Gradient.classNames.concat([RadialGradient.className]);\n\n\t/**\n\t * @ignore\n\t */\n\tpublic getFill(target: Sprite): IGradient {\n\t\tconst bounds = this.getBounds(target);\n\n\t\tlet x = 0;\n\t\tlet y = 0;\n\n\t\tlet l = bounds.left || 0;\n\t\tlet r = bounds.right || 0;\n\t\tlet t = bounds.top || 0;\n\t\tlet b = bounds.bottom || 0;\n\n\t\tconst width = r - l;\n\t\tconst height = b - t;\n\n\t\tlet radius = target.get(\"radius\" as any);\n\t\tif ($type.isNumber(radius)) {\n\t\t\tx = 0;\n\t\t\ty = 0;\n\t\t}\n\t\telse {\n\t\t\tradius = Math.min(width, height) / 2;\n\t\t\tx = width / 2;\n\t\t\ty = height / 2;\n\t\t}\n\n\t\tlet ux = this.get(\"x\");\n\t\tlet uy = this.get(\"y\");\n\t\tif (ux != null) {\n\t\t\tx = $utils.relativeToValue(ux, width);\n\t\t}\n\n\t\tif (uy != null) {\n\t\t\ty = $utils.relativeToValue(uy, height);\n\t\t}\n\n\t\tconst gradient = this._root._renderer.createRadialGradient(x, y, 0, x, y, radius);\n\t\tconst stops = this.get(\"stops\")!;\n\t\tif (stops) {\n\t\t\tlet i = 0;\n\t\t\t$array.each(stops, (stop) => {\n\n\t\t\t\tlet offset = stop.offset;\n\n\t\t\t\tif (!$type.isNumber(offset)) {\n\t\t\t\t\toffset = i / (stops.length - 1);\n\t\t\t\t}\n\n\t\t\t\tlet opacity = stop.opacity;\n\n\t\t\t\tif (!$type.isNumber(opacity)) {\n\t\t\t\t\topacity = 1;\n\t\t\t\t}\n\n\t\t\t\tlet color = stop.color;\n\n\t\t\t\tif (color) {\n\n\t\t\t\t\tconst lighten = stop.lighten;\n\t\t\t\t\tif (lighten) {\n\t\t\t\t\t\tcolor = Color.lighten(color, lighten)\n\t\t\t\t\t}\n\n\t\t\t\t\tconst brighten = stop.brighten;\n\t\t\t\t\tif (brighten) {\n\t\t\t\t\t\tcolor = Color.brighten(color, brighten)\n\t\t\t\t\t}\n\n\t\t\t\t\tgradient.addColorStop(offset, 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + opacity + ')');\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t})\n\t\t}\n\n\t\treturn gradient\n\t}\n}\n","import { Pattern, IPatternSettings, IPatternPrivate } from \"./Pattern\";\n\nimport * as $math from \"../../util/Math\";\n\nexport interface ICirclePatternSettings extends IPatternSettings {\n\n\t/**\n\t * Gap between circles, in pixels.\n\t *\n\t * @default 3\n\t */\n\tgap?: number;\n\n\t/**\n\t * Radius of the circles, in pixels.\n\t *\n\t * @default 3\n\t */\n\tradius?: number;\n\n\t/**\n\t * If set to `true`, will place every second circle, creating checkered\n\t * pattern.\n\t *\n\t * @default false\n\t */\n\tcheckered?: boolean;\n\n\t/**\n\t * Center circles.\n\t *\n\t * @default true\n\t */\n\tcentered?: boolean;\n\n}\n\nexport interface ICirclePatternPrivate extends IPatternPrivate {\n}\n\n/**\n * Circle pattern.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\n */\nexport class CirclePattern extends Pattern {\n\n\tdeclare public _settings: ICirclePatternSettings;\n\tdeclare public _privateSettings: ICirclePatternPrivate;\n\n\tpublic static className: string = \"CirclePattern\";\n\tpublic static classNames: Array<string> = Pattern.classNames.concat([CirclePattern.className]);\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\n\t\tif (this.isDirty(\"gap\")) {\n\t\t\tthis._clear = true;\n\t\t}\n\t}\n\n\tprotected _draw() {\n\t\tsuper._draw();\n\n\t\tconst checkered = this.get(\"checkered\", false);\n\t\tconst centered = this.get(\"centered\", true);\n\t\tconst gap = this.get(\"gap\", 0);\n\t\tconst rotation = this.get(\"rotation\", 0);\n\t\tlet w = this.get(\"width\", 100);\n\t\tlet h = this.get(\"height\", 100);\n\t\tlet radius = this.get(\"radius\", 3);\n\n\t\tlet cellW = radius * 2 + gap;\n\t\tlet cellH = radius * 2 + gap;\n\n\t\tlet cols = Math.round(w / cellW);\n\t\tlet rows = Math.round(h / cellH);\n\n\t\tcellW = w / cols;\n\t\tcellH = h / rows;\n\n\t\tif (rotation != 0) {\n\t\t\t// @todo this is probably not right\n\t\t\tthis._display.x = cellW * $math.cos(rotation);\n\t\t\tthis._display.y = cellH * $math.sin(rotation);\n\t\t}\n\n\t\tconst color = this.get(\"color\");\n\t\tconst colorOpacity = this.get(\"colorOpacity\");\n\t\tif (color || colorOpacity) {\n\t\t\tthis._display.beginFill(color, colorOpacity);\n\t\t}\n\n\t\tfor (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {\n\t\t\tfor (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {\n\t\t\t\tif (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {\n\t\t\t\t\tlet x = c * cellW;\n\t\t\t\t\tlet y = r * cellH;\n\t\t\t\t\tif (centered) {\n\t\t\t\t\t\tx += cellW + gap / 2;\n\t\t\t\t\t\ty += cellH + gap / 2;\n\t\t\t\t\t}\n\t\t\t\t\tthis._display.drawCircle(x - radius, y - radius, radius);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (checkered) {\n\t\t\tw = w / 2 - gap * 2;\n\t\t\th = h / 2 - gap * 2;\n\t\t}\n\t\telse {\n\t\t\tw -= gap;\n\t\t\th -= gap;\n\t\t}\n\n\t\tif (color || colorOpacity) {\n\t\t\tthis._display.endFill();\n\t\t}\n\n\t}\n}\n","import { Pattern, IPatternSettings, IPatternPrivate } from \"./Pattern\";\nimport * as $type from \"../../util//Type\";\n\nexport interface ILinePatternSettings extends IPatternSettings {\n\n\t/**\n\t * Gap between  lines, in pixels.\n\t *\n\t * @default 6\n\t */\n\tgap?: number;\n\n}\n\nexport interface ILinePatternPrivate extends IPatternPrivate {\n}\n\n/**\n * Line pattern.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\n */\nexport class LinePattern extends Pattern {\n\n\tdeclare public _settings: ILinePatternSettings;\n\tdeclare public _privateSettings: ILinePatternPrivate;\n\n\tpublic static className: string = \"LinePattern\";\n\tpublic static classNames: Array<string> = Pattern.classNames.concat([LinePattern.className]);\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\n\t\tif (this.isDirty(\"gap\")) {\n\t\t\tthis._clear = true;\n\t\t}\n\t}\n\n\tprotected _draw() {\n\t\tsuper._draw();\n\n\t\tconst w = this.get(\"width\", 100);\n\t\tconst h = this.get(\"height\", 100);\n\t\tconst gap = this.get(\"gap\", 0);\n\t\tconst strokeWidth = this.get(\"strokeWidth\", 1);\n\n\t\tif (!gap) {\n\t\t\tthis._display.moveTo(0, 0);\n\t\t\tthis._display.lineTo(w, 0);\n\t\t}\n\t\telse {\n\t\t\tlet step = gap + strokeWidth;\n\t\t\tlet count = h / step;\n\n\t\t\tfor (let i = -count; i < count * 2; i++) {\n\t\t\t\tconst y = Math.round(i * step - step / 2) + 0.5;\n\t\t\t\tthis._display.moveTo(-w, y);\n\t\t\t\tthis._display.lineTo(w * 2, y);\n\t\t\t}\n\t\t}\n\n\t\tthis._display.lineStyle(strokeWidth, this.get(\"color\"), this.get(\"colorOpacity\"));\n\n\t\tlet strokeDasharray = this.get(\"strokeDasharray\");\n\t\tif ($type.isNumber(strokeDasharray)) {\n\t\t\tif (strokeDasharray < 0.5) {\n\t\t\t\tstrokeDasharray = [0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstrokeDasharray = [strokeDasharray]\n\t\t\t}\n\t\t}\n\t\tthis._display.setLineDash(strokeDasharray as number[]);\n\n\t\tconst strokeDashoffset = this.get(\"strokeDashoffset\");\n\t\tif (strokeDashoffset) {\n\t\t\tthis._display.setLineDashOffset(strokeDashoffset);\n\t\t}\n\n\t\tthis._display.endStroke();\n\t}\n}\n","import { Pattern, IPatternSettings, IPatternPrivate } from \"./Pattern\";\n\nimport * as $math from \"../../util/Math\";\n\nexport interface IRectanglePatternSettings extends IPatternSettings {\n\n\t/**\n\t * Gap between rectangles, in pixels.\n\t *\n\t * @default 6\n\t */\n\tgap?: number;\n\n\t/**\n\t * Maximum width of the rectangle, in pixels.\n\t *\n\t * @default 5\n\t */\n\tmaxWidth?: number;\n\n\t/**\n\t * Maximum height of the rectangle, in pixels.\n\t *\n\t * @default 5\n\t */\n\tmaxHeight?: number;\n\n\t/**\n\t * If set to `true`, will place every second rectangle, creating checkered\n\t * pattern.\n\t *\n\t * @default false\n\t */\n\tcheckered?: boolean;\n\n\t/**\n\t * Center rectangles.\n\t *\n\t * @default true\n\t */\n\tcentered?: boolean;\n\n}\n\nexport interface IRectanglePatternPrivate extends IPatternPrivate {\n}\n\n/**\n * Rectangle pattern.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\n */\nexport class RectanglePattern extends Pattern {\n\tdeclare public _settings: IRectanglePatternSettings;\n\tdeclare public _privateSettings: IRectanglePatternPrivate;\n\n\tpublic static className: string = \"RectanglePattern\";\n\tpublic static classNames: Array<string> = Pattern.classNames.concat([RectanglePattern.className]);\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\n\t\tif (this.isDirty(\"gap\")) {\n\t\t\tthis._clear = true;\n\t\t}\n\t}\n\n\tprotected _draw() {\n\t\tsuper._draw();\n\n\t\tconst checkered = this.get(\"checkered\", false);\n\t\tconst centered = this.get(\"centered\", true);\n\t\tconst gap = this.get(\"gap\", 0);\n\t\tconst rotation = this.get(\"rotation\", 0);\n\t\tlet w = this.get(\"width\", 100);\n\t\tlet h = this.get(\"height\", 100);\n\t\tlet rectW = this.get(\"maxWidth\", 5);\n\t\tlet rectH = this.get(\"maxHeight\", 5);\n\n\t\tconst display = this._display;\n\n\t\tlet cellW = rectW + gap;\n\t\tlet cellH = rectH + gap;\n\n\t\tlet cols = Math.round(w / cellW);\n\t\tlet rows = Math.round(h / cellH);\n\n\t\tcellW = w / cols;\n\t\tcellH = h / rows;\n\n\t\tif (rotation != 0) {\n\t\t\t// @todo this is probably not right\n\t\t\tdisplay.x = cellW / 2 * $math.cos(rotation);\n\t\t\tdisplay.y = -cellH / 2 * $math.sin(rotation);\n\t\t}\n\n\t\tfor (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {\n\t\t\tfor (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {\n\t\t\t\tif (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {\n\t\t\t\t\tlet x = c * cellW;\n\t\t\t\t\tlet y = r * cellH;\n\t\t\t\t\tif (centered) {\n\t\t\t\t\t\tx += (cellW - rectW) / 2;\n\t\t\t\t\t\ty += (cellH - rectH) / 2;\n\t\t\t\t\t}\n\t\t\t\t\tdisplay.drawRect(x, y, rectW, rectH);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (checkered) {\n\t\t\tw = w / 2 - gap * 2;\n\t\t\th = h / 2 - gap * 2;\n\t\t}\n\t\telse {\n\t\t\tw -= gap;\n\t\t\th -= gap;\n\t\t}\n\n\t\tconst color = this.get(\"color\");\n\t\tconst colorOpacity = this.get(\"colorOpacity\");\n\t\tif (color || colorOpacity) {\n\t\t\t// this._display.lineStyle(strokeWidth, stroke, colorOpacity);\n\t\t\t// this._display.endStroke();\n\t\t\tdisplay.beginFill(color, colorOpacity);\n\t\t\tdisplay.endFill();\n\t\t}\n\n\t}\n}\n","import { Pattern, IPatternSettings, IPatternPrivate } from \"./Pattern\";\n\n//import * as $math from \"../../util/Math\";\n\nexport interface IPathPatternSettings extends IPatternSettings {\n\n\t// /**\n\t//  * Gap between Paths, in pixels.\n\t//  *\n\t//  * @default 6\n\t//  */\n\t// gap?: number;\n\n\t// /**\n\t//  * Maximum width of the Path, in pixels.\n\t//  *\n\t//  * @default 5\n\t//  */\n\t// maxWidth?: number;\n\n\t// /**\n\t//  * Maximum height of the Path, in pixels.\n\t//  *\n\t//  * @default 5\n\t//  */\n\t// maxHeight?: number;\n\n\t// /**\n\t//  * If set to `true`, will place every second Path, creating checkered\n\t//  * pattern.\n\t//  *\n\t//  * @default false\n\t//  */\n\t// checkered?: boolean;\n\n\t// /**\n\t//  * Center image.\n\t//  *\n\t//  * @default true\n\t//  */\n\t// centered?: boolean;\n\n\t/**\n\t * Use an SVG path as pattern.\n\t *\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths} for more information\n\t */\n\tsvgPath?: string;\n\n}\n\nexport interface IPathPatternPrivate extends IPatternPrivate {\n}\n\n/**\n * A pattern that uses an SVG path.\n *\n * @since 5.2.33\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\n */\nexport class PathPattern extends Pattern {\n\tdeclare public _settings: IPathPatternSettings;\n\tdeclare public _privateSettings: IPathPatternPrivate;\n\n\tpublic static className: string = \"PathPattern\";\n\tpublic static classNames: Array<string> = Pattern.classNames.concat([PathPattern.className]);\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\n\t\tif (this.isDirty(\"svgPath\")) {\n\t\t\tthis._clear = true;\n\t\t}\n\t}\n\n\tprotected _draw() {\n\t\tsuper._draw();\n\n\t\t// const checkered = this.get(\"checkered\", false);\n\t\t// const centered = this.get(\"centered\", true);\n\t\t// const gap = this.get(\"gap\", 0);\n\t\t// const rotation = this.get(\"rotation\", 0);\n\t\t// let w = this.get(\"width\", 100);\n\t\t// let h = this.get(\"height\", 100);\n\t\t// let rectW = this.get(\"maxWidth\", 5);\n\t\t// let rectH = this.get(\"maxHeight\", 5);\n\n\n\t\t// let cellW = rectW + gap;\n\t\t// let cellH = rectH + gap;\n\n\t\t// let cols = Math.round(w / cellW);\n\t\t// let rows = Math.round(h / cellH);\n\n\t\t// cellW = w / cols;\n\t\t// cellH = h / rows;\n\n\t\t// if (rotation != 0) {\n\t\t// \t// @todo this is probably not right\n\t\t// \tthis._display.x = cellW / 2 * $math.cos(rotation);\n\t\t// \tthis._display.y = -cellH / 2 * $math.sin(rotation);\n\t\t// }\n\n\t\t// for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {\n\t\t// \tfor (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {\n\t\t// \t\tif (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {\n\t\t// \t\t\tlet x = c * cellW;\n\t\t// \t\t\tlet y = r * cellH;\n\t\t// \t\t\tif (centered) {\n\t\t// \t\t\t\tx += (cellW - rectW) / 2;\n\t\t// \t\t\t\ty += (cellH - rectH) / 2;\n\t\t// \t\t\t}\n\t\t// \t\t\tthis._display.drawRect(x, y, rectW, rectH);\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\t// if (checkered) {\n\t\t// \tw = w / 2 - gap * 2;\n\t\t// \th = h / 2 - gap * 2;\n\t\t// }\n\t\t// else {\n\t\t// \tw -= gap;\n\t\t// \th -= gap;\n\t\t// }\n\n\t\tconst svgPath = this.get(\"svgPath\");\n\t\tif (svgPath != null) {\n\t\t\tthis._display.svgPath(svgPath!);\n\t\t}\n\n\t\tconst color = this.get(\"color\");\n\t\tconst colorOpacity = this.get(\"colorOpacity\");\n\t\tif (color || colorOpacity) {\n\t\t\t// this._display.lineStyle(strokeWidth, stroke, colorOpacity);\n\t\t\t// this._display.endStroke();\n\t\t\tthis._display.beginFill(color, colorOpacity);\n\t\t\tthis._display.endFill();\n\t\t}\n\n\t}\n}\n"],"names":["Picture","Sprite","constructor","Object","defineProperty","this","_root","_renderer","makePicture","undefined","_changed","super","isDirty","width","get","_display","$type","height","clear","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","shadowOpacity","_load","src","eventType","image","Image","crossOrigin","decode","then","_updateSize","catch","_error","events","isEnabled","dispatch","type","target","w","getPrivate","h","r","markDirtyBounds","markDirty","classNames","concat","className","Gradient","Entity","_afterNew","_afterNewApplyThemes","getFill","_target","addColorStop","_offset","_color","getBounds","gradientTarget","bounds","globalBounds","p0","toLocal","x","left","y","top","p1","right","p2","bottom","p3","Math","min","max","getLocalBounds","LinearGradient","rotation","l","t","b","cos","$math","sin","longer","gradient","createLinearGradient","stops","i","$array","stop","offset","length","opacity","color","lighten","Color","brighten","g","Star","Graphics","_beforeChanged","_clear","display","ir","$utils","spikes","step","PI","angle","moveTo","lineTo","closePath","HeatLegend","Container","children","push","new","labelContainer","Label","themeTags","ListTemplate","Template","RoundedRectangle","_new","markers","template","_settings","orientation","set","Tooltip","makeMarker","marker","make","states","create","showValue","value","text","tooltip","getTooltip","startValue","c","startColor","endColor","p","getNumberFormatter","format","interpolate","label","markerContainer","toGlobal","innerHeight","innerWidth","background","show","_prepareChildren","startLabel","endLabel","setAll","layout","verticalLayout","p100","horizontalLayout","centerY","centerX","stepCount","moveValue","reverse","Triangle","isPrivateDirty","_draw","Slider","Scrollbar","_addOrientationClass","endGrip","setPrivate","thumb","updateGrips","startGrip","setRaw","GrainPattern","Pattern","document","createElement","canvas","getContext","_clearGrain","patternData","context","getImageData","size","minOpacity","maxOpacity","colors","fromHex","cols","rows","density","horizontalGap","verticalGap","round","floor","random","alpha","rnd","_setRectData","data","putImageData","_pattern","createPattern","_checkDirtyFill","col","row","rc","gc","bc","ac","RadialGradient","radius","ux","uy","createRadialGradient","CirclePattern","checkered","centered","gap","cellW","cellH","colorOpacity","beginFill","drawCircle","endFill","LinePattern","strokeWidth","count","lineStyle","strokeDasharray","setLineDash","strokeDashoffset","setLineDashOffset","endStroke","RectanglePattern","rectW","rectH","drawRect","PathPattern","svgPath"],"sourceRoot":""}